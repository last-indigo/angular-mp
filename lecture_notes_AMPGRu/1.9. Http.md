## HTTP

на примере простого поиска 
(не typeahead, а обычный серч)

в качестве сервера json-server
следит за файлом db.json
поиск будет искать среди них

есть input + button (click)=clear()

1. нужен http module, вставляем в imports
app.module.ts

2. написать контрол,
который будет меняться и что-то искать
инициализирован FormControl'ом
`this.searchBar = new FormControl('', []);`

мы можем воспользоваться его свойством
Observable valueChanges и превратить в другой 
`this.searchBar.valueChanges`

в конструктор home.component 
-> передаем searchService (пустой пока что)

``` 
  .map( (query): string => query.trim() )
```

наверное не стоит начинать поиск с одного символа,
``` 
  .filter( (query): string => query && query.length >= 2)
```

нужен debounce 
для задержки потока есть delay но она не подходит:
задержит, но сделает все запросы, просто отложенные
а debounce ждет истечения времени по частоте 
и отправит только один

```
.debounce( () => Observable.timer(250) )
```
has to return the Obs.timer

```
.do( () => {
  this.isLoading = true
})
```

```
.subscribe( query: string => {
  console.log(query);
})
```

мы сделали контроллер который ограничивает
частоту и характер потенциальных запросов
и теперь нужно дергать поиск

```
.map( query: string => this.searchService.search(query) )
```

и после этого
```
.switch()
```
switch смотрит чем является предыдущее значение
и если оно стрим, то превращает текущий стрим в 
значения из полученного стрима

для совершения реквеста нам нужен сервис Http из кора

`this.http.request(url, requestOptions)`

json-server создает контроллер по пути объекта в db.json

```
let options = new RequestOptions()
options.method
options.url
options.search
options.headers
```


`/users?name_like=text`

RequestMethod.<method name>
// ангулар enum, в котором хранятся допустимые значения

```
this.http.request(new Request(requestOptions))
  .map( res: Response => res.json() )
```

```  
new URLSearchParams()
urlParams.set(key, val)
```
можно сохранять проперти и каждый раз 
вручную отписываться в ngOnDestroy
this.subscription.unsubscribe()

но можно сохранить this.users как Observable<Users[]>
и в темплейте юзать пайп `.. of users | async`
так будет лаконичнее + он сам себя отписывает на onDestroy
не придется заморачиваться с отписками

async - единственный stateful pipe из коробки

`Headers.set('My-Value', 'bla')`
может отправить lowercase, т.к. http делает normalize 
и есть jsdoc в исходниках с объяснением почему так
в новой версии ангулара это вроде бы выпилили

интерсептеры - extends Http и там уже оборачивать
каждый метод своими дополнениями

