## rxmarbles
.catch(error => Rx.Observable.just('error occured'))

  ({
    ... throw 'error'
  })
  .retry(2)
    0
    1
    2
    0
    1
    2
    x 'bad error'

.retryWhen( err => .delay(2000).take(2) )

err.scan( (errCount, err) =>
  errCount: is an accumulator

Promise занимает ресурсы всегда
Observable оптимизирован: если на него никто не подписался, то
поток не будет создан (колбек по созданию не отработает)
  Может return функцию onDestroy(?уточнить) для освобождения ресурсов
  которая вызывается на sub1.dispose()

obs.forEach - тоже подписчик, перебирает коллекцию (имеет к ней доступ)
а subscribe получает значения из этой коллекции/потока

для каждого подписчика - отдельный обзервабл (????) 11:39 на часах
  см. (connect / hot observable) ниже

dispose/или/unsubscribe?
синтаксис Angular зависит от версии от RxJS

функциональное программирование - переиспользуемые блоки кода

можно конкат поток, фильтровать (все похоже как у массивов)

Pure functions
получают поток но не изменяют, а возвращают новый преобразованный

Buffers
  .buffer()
  .bufferWithCount()
  .bufferWithTime()
  .bufferWithTimeOrCount()

val clicks = Rx.Observable.fromEvent(myButton, 'click')
var delayedClicks = clicks.delay(1200)
// накапливает/собирает значения в течение времени, и по окончании отдает сумму

var bufferedClicks = clicks
 .buffer( () => delayedClicks ) // передает массив в след подписчик аргументом
 .map( clickBuffer => clickBuffer.length )

буфер спит. как только значение пришло - упаковывает все


.flatMapFirst - мерж потоков

.merge - сохраняет хронологию потоков
.concat - последовательно соединяет

.merge
.mergeAll
.mergeDelayError

Merge (!) хотим подписаться на два потока, но одним подписчиком
  var source3 = source1.merge(source2)
  source3.subscribe(...
новый поток закончится когда закончится последний из смерженных

.take(3) -- ограничить и закончить, чтобы не был бесконечным
.startWith(0) - задать исходное значение

.map( Rx.Observable.timer() ... ) - из потока получаем еще один поток, а не его значения
.mergeAll()
  берет все вторичные/производные потоки, и встраивает в основной один поток

.flatMap === усовершенствованный map, встраивает как .mergeAll
  и не обязательно использовать потом .mergeAll

.mergeDelayError
  выполнится после завершения результирующего потока

Hot & Cold observables
  до этого были холодные

hot observable - типа трансляции
весь поток проигрывается с самого начала, не зависимо от времени
и состояния потока в других подписчиках

.publish() - делает поток горячим
  == connectable observables

нужно не только создать, но и выполнить процедуру подключения

clock.connect();
выдает одни и те же значения, не пересоздает поток

.refCount() - управляет подключением горячего потока
  .publish()
  .refCount()

.shareReplay(1) -- **что-то про сервер**
  получать не null а предыдущее значение

  .publish()
  .refCount()

eventEmitter - subject, микс emitter+subscriber
  subject.subscribe
  subject.onNext
  subject.dispose

var subject = new Rx.BehaviorSubject()    // разновидность сабжекта, как shareReplay. горячий
var subSource = source.subscribe(subject)
subject.subscribe(...)

в Angular2, http возвращает observable
http.get('/api/googs')
  .catch()
  .subscribe()

ngRxStore - реализация redux

(?) будет ли два запроса после .get если есть два подписчика
если холодный - два
если горячий - один
> по опыту - холодный, будет два раза

пайп | async
  позволяет работать с обзерв, асинх значениями
  ="let item of items | async"

в конце презентации
  xgrommx.github.io/rx-book


